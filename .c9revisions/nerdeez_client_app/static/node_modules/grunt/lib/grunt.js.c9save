{"ts":1374211128086,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * grunt\n * http://gruntjs.com/\n *\n * Copyright (c) 2013 \"Cowboy\" Ben Alman\n * Licensed under the MIT license.\n * https://github.com/gruntjs/grunt/blob/master/LICENSE-MIT\n */\n\n'use strict';\n\n// Nodejs libs.\nvar path = require('path');\n\n// This allows grunt to require() .coffee files.\nrequire('coffee-script');\n\n// The module to be exported.\nvar grunt = module.exports = {};\n\n// Expose internal grunt libs.\nfunction gRequire(name) {\n  return grunt[name] = require('./grunt/' + name);\n}\nvar util = gRequire('util');\ngRequire('template');\ngRequire('event');\nvar fail = gRequire('fail');\ngRequire('file');\nvar option = gRequire('option');\nvar config = gRequire('config');\nvar task = gRequire('task');\nvar log = gRequire('log');\nvar help = gRequire('help');\ngRequire('cli');\nvar verbose = grunt.verbose = log.verbose;\n\n// Expose some grunt metadata.\ngrunt.package = require('../package.json');\ngrunt.version = grunt.package.version;\n\n// Expose specific grunt lib methods on grunt.\nfunction gExpose(obj, methodName, newMethodName) {\n  grunt[newMethodName || methodName] = obj[methodName].bind(obj);\n}\ngExpose(task, 'registerTask');\ngExpose(task, 'registerMultiTask');\ngExpose(task, 'registerInitTask');\ngExpose(task, 'renameTask');\ngExpose(task, 'loadTasks');\ngExpose(task, 'loadNpmTasks');\ngExpose(config, 'init', 'initConfig');\ngExpose(fail, 'warn');\ngExpose(fail, 'fatal');\n\n// Expose the task interface. I've never called this manually, and have no idea\n// how it will work. But it might.\ngrunt.tasks = function(tasks, options, done) {\n  // Update options with passed-in options.\n  option.init(options);\n\n  // Display the grunt version and quit if the user did --version.\n  var _tasks, _options;\n  if (option('version')) {\n    // Not --verbose.\n    log.writeln('grunt v' + grunt.version);\n\n    if (option('verbose')) {\n      // --verbose\n      verbose.writeln('Install path: ' + path.resolve(__dirname, '..'));\n      // Yes, this is a total hack, but we don't want to log all that verbose\n      // task initialization stuff here.\n      grunt.log.muted = true;\n      // Initialize task system so that available tasks can be listed.\n      grunt.task.init([], {help: true});\n      // Re-enable logging.\n      grunt.log.muted = false;\n\n      // Display available tasks (for shell completion, etc).\n      _tasks = Object.keys(grunt.task._tasks).sort();\n      verbose.writeln('Available tasks: ' + _tasks.join(' '));\n\n      // Display available options (for shell completion, etc).\n      _options = [];\n      Object.keys(grunt.cli.optlist).forEach(function(long) {\n        var o = grunt.cli.optlist[long];\n        _options.push('--' + (o.negate ? 'no-' : '') + long);\n        if (o.short) { _options.push('-' + o.short); }\n      });\n      verbose.writeln('Available options: ' + _options.join(' '));\n    }\n\n    return;\n  }\n\n  // Init colors.\n  log.initColors();\n\n  // Display help and quit if the user did --help.\n  if (option('help')) {\n    help.display();\n    return;\n  }\n\n  // A little header stuff.\n  verbose.header('Initializing').writeflags(option.flags(), 'Command-line options');\n\n  // Determine and output which tasks will be run.\n  var tasksSpecified = tasks && tasks.length > 0;\n  tasks = task.parseArgs([tasksSpecified ? tasks : 'default']);\n\n  // Initialize tasks.\n  task.init(tasks);\n\n  verbose.writeln();\n  if (!tasksSpecified) {\n    verbose.writeln('No tasks specified, running default tasks.');\n  }\n  verbose.writeflags(tasks, 'Running tasks');\n\n  // Handle otherwise unhandleable (probably asynchronous) exceptions.\n  var uncaughtHandler = function(e) {\n    fail.fatal(e, fail.code.TASK_FAILURE);\n  };\n  process.on('uncaughtException', uncaughtHandler);\n\n  // Report, etc when all tasks have completed.\n  task.options({\n    error: function(e) {\n      fail.warn(e, fail.code.TASK_FAILURE);\n    },\n    done: function() {\n      // Stop handling uncaught exceptions so that we don't leave any\n      // unwanted process-level side effects behind. There is no need to do\n      // this in the error callback, because fail.warn() will either kill\n      // the process, or with --force keep on going all the way here.\n      process.removeListener('uncaughtException', uncaughtHandler);\n\n      // Output a final fail / success report.\n      fail.report();\n\n      if (done) {\n        // Execute \"done\" function when done (only if passed, of course).\n        done();\n      } else {\n        // Otherwise, explicitly exit.\n        util.exit(0);\n      }\n    }\n  });\n\n  // Execute all tasks, in order. Passing each task individually in a forEach\n  // allows the error callback to execute multiple times.\n  tasks.forEach(function(name) { task.run(name); });\n  task.start();\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":4674}]],"length":4674}
